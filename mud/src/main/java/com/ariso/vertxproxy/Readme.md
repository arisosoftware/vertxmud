Readme.txt
	// 本地
		// 启动：
			// 读取本地秘钥，建立5个数据包，并连接，发送到云端特定端口
			// 
		// 监听本地网络，然后把数据加密，传送到 云端上面
		// 接受来自云端的数据，解密，然后传回本地网。
	
	// 云端
		// 接受代理发来的链接请求
			// 接受代理发来的登陆数据包，一共3-5个数据包，其中一个是对的
			// 一个个计算md5，然后对md5进行aes加密，如果和发来的数据包是一致的。说明是验证用户。其他数据包是伪造，可以直接丢弃
			// 当验证成功。发还一个成功的数据包。里面也是用aes加密。
	
	    // 通道建立
	    	// 接受来自客端的数据，解密，然后 转发到sock5代理端
	    	// 接受来自sock5代理的数据，加密，然后转发到客端
	    
	    
----------简易版本的设计。 draft version
# 本地
	## 启动
		### 读取配置,得到key和远程接力服务器的ip/port
			####配置有
				#####	    
	    
	    
	 关于对抗 GFW 的特征检测
不论是 Shadowsocks 还是 VPN 或 SSH 隧道，共性都很明显——长时间的 TCP 长连接。
这样一种特征，非常明显是被用来翻墙。

或许可以考虑换一种思路：
用普通的，明文的 HTTP 请求来承载上层的翻墙数据。

以 SOCKS 代理为例：
把 SOCKS 代理切割成两个部分，一部分部署在客户端，一部分部署在 VPS。
两者之间的通讯，伪装成普通的，明文的 HTTP 流量。
（表面上看，像是明文的，但是承载的数据，依然用加密方式，比如打包成图片的内容